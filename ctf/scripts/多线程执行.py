import time
# python3.6
# 把获得的n粘过来，加一个0x表示十六进制整数。或者也可以用python提取pubkey.pem中的n和e
n = 0xB0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929

# 打开flag.enc，将字节串转换为整数
with open('flag.enc', 'rb') as f:
	hex_c = f.read()
c = int.from_bytes(hex_c, byteorder = 'big')

# 计算 c mod n
mod = c % n

# 引入gmpy2库用于求n次方根
import gmpy2

# 写一个测试函数，k在i，j范围内测试立方根
def test(i, j):
	for k in range(i, j):
		res, is_exact = gmpy2.iroot(k * n + mod, 3)
		if is_exact:
			print(k, res)
	print(time.asctime(),'-', i,'-', j)

# 引入多进程库，由于GIL的存在，cpython只能在进程级别上并行
import multiprocessing

# 开始遍历
# 我的CPU是8个逻辑核，所以开8个进程，每个进程分配到18750000个。


if __name__ == '__main__':
	print(time.asctime())
	for i in range(0, 150000000, 18750000):
		p = multiprocessing.Process(target = test, args = (i, i + 18750000))
		p.start()